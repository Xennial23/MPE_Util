# -*- coding: utf-8 -*-
# Copyright (c) 2017-2018 Juho Hella

"""
DISCLAIMER:
Use at your own risk! This remote script may be able to destroy Live installation or set! Be sure to backup your project
folder before opening a Live set whilst this script is active!

KNOWN ISSUES:
Use global launch quantization! If it is set to None, firing of clips will be slightly out of sync as the script has to
wait to get called by Live (in parse) to change properties on other tracks.

About the code: All the code in the project, except for parts in this file and the __init__.py -files, are cloned
from another, private (at least for the time being), MIDI Remote Script project of mine. The source project is quite
a bit more complicated, than this one. Many of the solutions found from this package, which seem odd or over
complicated for the functionality required by the MPE_Util were (and are) developed as a part of the more complicated
project. This way the any modifications are easy to take to both projects. As an example, the InstanceContainerModule
helps in the complex project when all the required instances are easily found across the modules.

Utlized modules
Live - Ableton's LOM-package
DelayedCallbackHandler - a module which handles delayed callbacks. Needed when remote script has to wait before
    performing operations, for example when doing successive calls to LOM-object.
InstanceContainer - a module in which various instances needed around are kept in.
ItemModelDataHandler - Handles saving and loading of the data generated by the script.
itemmodelmixins - a package which contain class extensions, only for the MPE-functionality in this script.

UtilContainerModule - a module with some useful functions, such as log_message

SongModel holds the Live set. TrackList maintains the song.tracks-LOM, and creates TrackModels, MidiTrackModels or
GroupMasterTrackModels, which contain needed functionality. MPEMixInClasses (from itemmodelmixins) extend the
MidiTrackModels when utilized.

"""


from __future__ import with_statement


import re
import Live
from ableton.v2.control_surface.control_surface import ControlSurface

from UtilContainer import log_message, log_error
from DelayedCallbackHandler import DelayedCallbackHandler
import conf
import ItemModelDataHandler
from itemmodelmixins import *


class MPE_Util(ControlSurface):
    """ The main class. Initializes the delayedCallbackHandler, itemModelDataHandlerSongModel and calls the delayedCallbackHandler to run delayed callbacks
      at the end of each cycle.
    """
    def __init__(self, c_instance):
        versionStr = "Live_{0}_{1}_{2}".format(self.application.get_major_version(),
                                               self.application.get_minor_version(),
                                               self.application.get_bugfix_version())

        #Call the ableton.v2.control_surface.control_surface init
        super(MPE_Util, self).__init__(c_instance)

        # Initialize the required instances to the InstanceContainer.
        InstanceContainer.song = self.song
        InstanceContainer.itemModelDataHandler = ItemModelDataHandler.ItemModelDataHandler("MPE_Util")
        self.delayedCallbackHandler = DelayedCallbackHandler()
        InstanceContainer.add_delayed_callback = self.delayedCallbackHandler.add_delayed_callback
        InstanceContainer.get_delayed_callback_exists = self.delayedCallbackHandler.get_delayed_callback_exists
        
        with self.component_guard():
            self.songModel = SongModel(self.song)
            self.parse()
        log_message("MPE_Util running on",versionStr)
        self.show_message("MPEUtil loaded!")
        


    def parse(self):
        """ This method gets called on each cycle. Simply calls the delayedCallbackHandler and schedules itself to be
          called on the next cycle.
        """
        self.delayedCallbackHandler.run_cycles_delayed_callbacks()
        self.schedule_message(1, self.parse)


class SongModel(object):
    """ SongModel class extends the Song.Song LOM-object.
      In this context, only the _ghostMidiInputTrack property is added, and the TrackListModel created.

    """

    @property
    def _ghostMidiInputTrack(self):
        return self.__ghostMidiInputTrack

    @_ghostMidiInputTrack.setter
    def _ghostMidiInputTrack(self, value):
        if value != self.__ghostMidiInputTrack:
            self.__ghostMidiInputTrack = value
            if type(value) is not str:
                self._call_ghostMidiInputTrack_listeners()

    def _call_ghostMidiInputTrack_listeners(self):
        for tempCallback in self._ghostMidiInputTrackListeners:
            tempCallback()

    def add_ghostMidiInputTrack_listener(self, callback):
        if callback not in self._ghostMidiInputTrackListeners:
            self._ghostMidiInputTrackListeners.append(callback)

    def remove_ghostMidiInputTrack_listener(self, callback):
        if callback in self._ghostMidiInputTrackListeners:
            self._ghostMidiInputTrackListeners.remove(callback)

    def __init__(self, songObject):
        InstanceContainer.songModel = self
        self.itemType = 'Song.Song'
        self.itemModelPointer = 'song'
        self.parentItemModel = None
        self.item = songObject
        self._ghostMidiInputTrackListeners = []
        self.__ghostMidiInputTrack = None
        self.trackListModel = TrackListModel(self.item.tracks, self)
        self.foundExternalData = InstanceContainer.itemModelDataHandler.get_itemModels_external_data(self)


    def _create_ghostMidiInputTrack(self):
        # Create a ghostMidiInputTrack..
        tempChannelId = len(self.item.tracks)

        self.item.create_midi_track(tempChannelId)

        def set_ghostMidiInputTrackPhase2(ghostTrackImp):
            ghostMidiInputTrackModel = self.trackListModel.get_track_model_by_IMP(ghostTrackImp)
            ghostMidiInputTrackModel._mix_with_class("GhostMidiInputTrackMix")
            return True

        def set_ghostMidiInputTrackPhase1(ghostTrackId):
            trackItem = self.item.tracks[ghostTrackId]
            trackItem.name = "GhostMidiInput"
            #Color to gray..
            trackItem.color = 8421504
            trackItem.input_routing_type = trackItem.available_input_routing_types[-1]
            keyForSetGhostMidiInputTrackPhase2 = "set-GhostMidiInputTrack-Phase2"
            InstanceContainer.add_delayed_callback(keyForSetGhostMidiInputTrackPhase2, set_ghostMidiInputTrackPhase2, (trackItem._live_ptr,), {})
            return True

        keyForSetGhostMidiInputTrackPhase1 = "set-GhostMidiInputTrack-Phase1"
        InstanceContainer.add_delayed_callback(keyForSetGhostMidiInputTrackPhase1, set_ghostMidiInputTrackPhase1, (tempChannelId,), {})
        self._ghostMidiInputTrack = "GhostMidiInput"
        return True

class TrackListModel(object):
    """ TrackListModel extends the song instance's 'tracks' Base.ItemList LOM object.
      It listens for changes in the list, and creates item models for all the tracks (the exact type depending
      on the track in question).
    """
    def __init__(self, trackListObject, parentItemModel):
        self.itemType = 'Base.ItemList'
        self.itemModelPointer = 'song/tracks'
        self.itemNameOnParentItem = 'tracks'
        self.parentItemModel = parentItemModel
        self.item = trackListObject

        self._trackModels = {}
        self._handle_track_list()
        self.parentItemModel.item.add_tracks_listener(self._handle_track_list)

    def _handle_track_list(self):
        self.item = self.parentItemModel.item.tracks
        log_message("Weeee, tracks changed! len now:",len(self.item))
        tracksToFind = self._trackModels.keys()[:]
        for x in range(0,len(self.item)):
            #log_message("Checking itemId:",x)
            tempTrack = self.item[x]
            tempTrackImp = str(tempTrack._live_ptr)
            if tempTrackImp in tracksToFind:
                #log_message("Track:",x,tempTrack.name,"exists! x!=itemId:",x != self._trackModels[tempTrackImp].itemId)
                tracksToFind.remove(tempTrackImp)
                if x != self._trackModels[tempTrackImp].itemId:
                    self._trackModels[tempTrackImp].itemId = x
            else:
                #log_message("New track added!")
                if tempTrack.is_foldable:
                    self._trackModels[tempTrackImp] = GroupMasterTrackModel(tempTrack, x, self)
                elif tempTrack.has_midi_input:
                    self._trackModels[tempTrackImp] = MidiTrackModel(tempTrack, x, self)
                else:
                    self._trackModels[tempTrackImp] = TrackModel(tempTrack, x, self)

        for tempDeletedTrackLptr in tracksToFind:
            log_message("Found deleted track:", tempDeletedTrackLptr,"had itemId:",self._trackModels[tempDeletedTrackLptr].itemId)
            self._trackModels[tempDeletedTrackLptr].disconnect()
            del self._trackModels[tempDeletedTrackLptr]

    def get_track_model_by_IMP(self, imp):
        if type(imp) is not str:
            imp = str(imp)
        if imp in self._trackModels:
            return self._trackModels[imp]
        else:
            return None

class TrackModel(object):
    """ TrackModel extends a Track.Track LOM-object. It extends it with properties and methods required by the MPE
      functionality and the ItemModelDataHandler.
    """
    def __init__(self, trackObject, itemId, parentItemModel):
        self.itemModelPointer = str(trackObject._live_ptr)
        self.parentItemModel = parentItemModel
        self.mixedWithClasses = []
        self.item = trackObject
        self._itemId = itemId
        self._itemId_listeners = []


        self._s_name_listeners = []
        self._update_s_name()
        #self.itemId = property(self._get_itemId, self._set_itemId)

        self.item.add_name_listener(self._name_changed_callback)

        if self.item.has_midi_input:
            self.itemType = "Track.MidiTrack"
        else:
            self.itemType = "Track.AudioTrack"

        self.itemNamingInfo = None
        self._listenToPostfixes = None
        if self.itemType in conf.itemTypeNamingInfos:
            self.itemNamingInfo = conf.itemTypeNamingInfos[self.itemType]
            if 'postfixCallableFunctions' in self.itemNamingInfo:
                self._listenToPostfixes = {}
                for tempFunctionName, tempPostfixInfo in self.itemNamingInfo['postfixCallableFunctions'].iteritems():
                    for tempPostfixStr in tempPostfixInfo['postfixes']:
                        tempRegexStr = tempPostfixInfo['regexBase'].replace("#POSTFIX#", tempPostfixStr)
                        try:
                            self._listenToPostfixes[tempRegexStr] = getattr(self, tempPostfixInfo['callback'])
                        except AttributeError:
                            log_error("Object of type:",self.itemType,"doesn't have callback function named:", "'"+tempPostfixInfo['callback']+"'", "cannot create calback to listen for name postfix with regex:","'"+tempRegexStr+"'")
                            


        self.foundExternalData = InstanceContainer.itemModelDataHandler.get_itemModels_external_data(self)


    @property
    def s_name(self):
        """ s_name is the tracks name without the index-number at the beginning. """
        return self._s_name

    @s_name.setter
    def s_name(self, value):
        self._s_name = value
        self._s_name_changed()

    def _s_name_changed(self):
        for tempCallback in self._s_name_listeners:
            tempCallback()

    def add_s_name_listener(self, callback):
        if callback not in self._s_name_listeners:
            self._s_name_listeners.append(callback)

    def _update_s_name(self):
        prefixlen = 0
        prevNum = True
        for tempChar in self.item.name:
            if prevNum and tempChar.isdigit():
                prefixlen += 1
            elif prevNum and (tempChar == ' ' or tempChar == '-'):
                prefixlen +=1
                prevNum = False
            else:
                break

        self.s_name = self.item.name[prefixlen:]

    @property
    def itemId(self):
        """ itemId is the index of the track in the tracks list. The name is due this code is derived from a far more
          complex project in which items may have their id by properties name or list index.
        """
        return self._itemId

    @itemId.setter
    def itemId(self, value):
        if value != self._itemId:
            self._itemId = value
            self._itemId_changed()

    def _itemId_changed(self):
        for tempCallback in self._itemId_listeners:
            tempCallback()

    def add_itemId_listener(self, callback):
        self._itemId_listeners.append(callback)

    def _name_changed_callback(self):
        postfixFound = False
        if self._listenToPostfixes != None:
            freshName = self.item.name
            for tempPostfixRegexStr, tempCallbackFn in self._listenToPostfixes.iteritems():
                #log_message("Checking for fresh name: ",freshName, "with regexstatement: ", tempPostfixRegexStr)
                if not postfixFound:
                    match = re.search(tempPostfixRegexStr, freshName, re.IGNORECASE)
                    if match:
                        log_message("Found match!! command: ",match.group('command'), "and num_arg:", match.group('num_arg'));
                        def delayedCallbackToFixName(newName):
                            self.item.name = newName
                            return True

                        InstanceContainer.add_delayed_callback("CallbackForPostfixNameFix", delayedCallbackToFixName,
                                                               [match.group('item_name')], {})
                        postfixFound = True

                        InstanceContainer.add_delayed_callback("CallbackForPostfixMethodCall", tempCallbackFn, [match],
                                                                   {}, delayCycles=2)

        if not postfixFound:
            self._update_s_name()

    def disconnect(self):
        #TODO: remove from itemModelDataHandler
        pass


    def _mix_with_class(self, toMixWithClassName, *args, **kwargs):
        """ Adds specific functionality to the TrackModel instance. toMixWithClassName is a name of a class from
        itemmodelmixins package
        """
        if toMixWithClassName in globals():
            tempMixedClass = globals()[toMixWithClassName]
            # log_message("WEEEEE, would mix:",self.itemType, "with:",toMixWithClassName, "class:", tempMixedClass)

            cls = self.__class__
            # self.__class__ = cls.__class__(cls.__name__+"_"+toMixWithClassName, (cls, tempMixedClass), {})
            self.__class__ = cls.__class__(cls.__name__, (cls, tempMixedClass), {})
            tempMixedClassesInitName = "_" + toMixWithClassName + "_init"
            if hasattr(self, tempMixedClassesInitName):
                # log_message("Calling tempMixedClassesInitName:",tempMixedClassesInitName)
                getattr(self, tempMixedClassesInitName)(*args, **kwargs)
            else:
                log_message("[ERROR!] Can't find toMixWithClasses:", toMixWithClassName, "init-method by name:",
                            tempMixedClassesInitName)


        else:
            log_message("ERROR! Can't mix with class:", toMixWithClassName, "not found from globals()!")

    def _call_mixed_with_post_inits(self):
        for tempMixedClassName in self.mixedWithClasses:
            tempPostInitMethodName = "_" + tempMixedClassName + "_postInit"
            if hasattr(self, tempPostInitMethodName):
                # log_message("Calling mixed classes postInit:",tempPostInitMethodName)
                getattr(self, tempPostInitMethodName)()

    def set_input_routing_channel_by_channel_display_name(self, channel_display_name):
        """
        {
            "returns": "bool",
            "args": [
                {
                  "type": "str",
                  "defaultValue": null,
                  "optional": false,
                  "name": "channel_display_name",
                  "str": ""
                }

            ],
            "kwargs": {},
            "desc": "Tries to set track's input_routing_channel to routing channel with display_name value of arg str."
        }
        """
        itemByName = None
        for tempRoutingChannel in self.item.available_input_routing_channels:
            if tempRoutingChannel.display_name == channel_display_name:
                itemByName = tempRoutingChannel

        if itemByName is not None:
            # log_message("Found, trying to set..",itemByName," named:",itemByName.display_name,"on item:",self.itemModelPointer,"named",self.s_name)
            self.item.input_routing_channel = itemByName
            return True
        else:
            log_message("[Warning] set_input_routing_channel_by_channel_display_name on MidiTrack:",
                        self.itemModelPointer, "can't find input_routing_channel with display_name:",
                        channel_display_name)
        return False

    def set_input_routing_type_by_types_display_name(self, type_display_name):
        """
        {
            "returns": "bool",
            "args": [
                {
                  "type": "str",
                  "defaultValue": null,
                  "optional": false,
                  "name": "type_display_name",
                  "str": ""
                }

            ],
            "kwargs": {},
            "desc": "Tries to set track's input_routing_type to routing type with display_name value of arg str."
        }
        """

        itemByName = None
        for tempRoutingType in self.item.available_input_routing_types:
            if tempRoutingType.display_name == type_display_name:
                itemByName = tempRoutingType
        if itemByName is not None:
            # log_message("Found, trying to set..")
            self.item.input_routing_type = itemByName
            return True
        else:
                log_message("[Warning] set_input_routing_type_by_channel_display_name on MidiTrack:", self.itemModelPointer,
                        "can't find input_routing_type with display_name:", type_display_name)
        return False

    def set_output_routing_channel_by_channel_display_name(self, channel_display_name):
        """
        {
            "returns": "bool",
            "args": [
                {
                  "type": "str",
                  "defaultValue": null,
                  "optional": false,
                  "name": "channel_display_name",
                  "str": ""
                }

            ],
            "kwargs": {},
            "desc": "Tries to set track's output_routing_channel to routing channel with display_name value of arg str."
        }
        """

        itemByName = None
        for tempRoutingChannel in self.item.available_output_routing_channels:
            if tempRoutingChannel.display_name == channel_display_name:
                itemByName = tempRoutingChannel
        if itemByName is not None:
            # log_message("Found, trying to set..")
            self.item.output_routing_channel = itemByName
            return True
        else:
            log_message("[Warning] set_output_routing_channel_by_channel_display_name on MidiTrack:",
                        self.itemModelPointer, "can't find output_routing_channel with display_name:",
                        channel_display_name)
        return False

    def set_output_routing_type_by_types_display_name(self, type_display_name):
        """
        {
            "returns": "bool",
            "args": [
                {
                  "type": "str",
                  "defaultValue": null,
                  "optional": false,
                  "name": "type_display_name",
                  "str": ""
                }

            ],
            "kwargs": {},
            "desc": "Tries to set track's output_routing_type to routing type with display_name value of arg str."
        }
        """
        itemByName = None
        for tempRoutingType in self.item.available_output_routing_types:
            if tempRoutingType.display_name == type_display_name:
                itemByName = tempRoutingType
        if itemByName is not None:
            # log_message("Found, trying to set..")
            self.item.output_routing_type = itemByName
            return True
        else:
            log_message("[Warning] set_output_routing_type_by_channel_display_name on MidiTrack:",
                        self.itemModelPointer, "can't find output_routing_type with display_name:", type_display_name)
        return False

class MidiTrackModel(TrackModel):
    """ Extension to the TrackModel, providing MidiTrack specific functionality (MPE-stuff). """
    def __init__(self, *a, **kw):

        super(MidiTrackModel, self).__init__(*a, **kw)
        self.itemType = "Track.MidiTrack"
        if self.foundExternalData is not None:
            log_message("Weeee, track:",self.itemId,self.itemModelPointer,"found external data:",self.foundExternalData)
            if 'isMPEMasterTrack' in self.foundExternalData and self.foundExternalData['isMPEMasterTrack'] is True:
                log_message("In externalData for MidiTrackModel:",self.itemModelPointer,
                            "isMpeMasterTrack is found True! setting delayed call.")
                def callbackForDelayedMPEMasterStatusUpdate():
                    log_message("Loading a mpeMasterTrack, after delay, calling:",
                                "self.create_mpe_input_tracks(loadingTracks=True)")
                    self.create_mpe_input_tracks(loadingTracks=True)
                    return True
                InstanceContainer.add_delayed_callback("callbackToLoadMPESubtracksFor"+self.itemModelPointer, callbackForDelayedMPEMasterStatusUpdate, [], {}, delayCycles=2)

            elif 'isMPESubTrack' in self.foundExternalData and self.foundExternalData['isMPESubTrack'] is True:
                self._mpeChannelId = self.foundExternalData['_mpeChannelId']
            elif 'isGhostMidiInputTrack' in self.foundExternalData and self.foundExternalData['isGhostMidiInputTrack'] is True:
                log_message("In externalData for MidiTrackModel:", self.itemModelPointer,
                            "isGhostMidiInputTrack is found True! Mixing..")
                self._mix_with_class("GhostMidiInputTrackMix")

    def _create_mpe_input_tracks_caller(self, match):
        if match.group('num_arg') != '' and 1 <= int(match.group('num_arg')) and int(match.group('num_arg')) <= 16:
            self.create_mpe_input_tracks(inputTrackCount=int(match.group('num_arg')))
        else:
            self.create_mpe_input_tracks()

        return True

    def create_mpe_input_tracks(self, loadingTracks=False, inputTrackCount=None):
        """ Mixes the MidiTrackModel with MPEMasterTrackMixIn class. loadingTracks is True when a Live set is loaded,
        inputTrackCount may be given as a parameter, otherwise read from conf. Creates new midi tracks,
        or loads existing ones, and routes them to act as MPE input channels for this tracks instrument via utilizing
        the MPESubTrackMixIn class.

        """

        if loadingTracks:
            existingMpeTracks = []
            for tempOldMPESubTrackModelIMP in self.foundExternalData["_mpeSubtracks"]:
                #log_message("Loading subtrack with imp:",tempOldMPESubTrackModelIMP)
                if tempOldMPESubTrackModelIMP in InstanceContainer.itemModelDataHandler.loadedItemModelPointersToCurrentItemModels:
                    existingMpeTracks.append(
                        InstanceContainer.itemModelDataHandler.loadedItemModelPointersToCurrentItemModels[
                            tempOldMPESubTrackModelIMP])
                else:
                    log_message("[ERROR!] unable to find old imp:", tempOldMPESubTrackModelIMP,
                                "from loadedImpsToCurrentImps:",
                                InstanceContainer.itemModelDataHandler.loadedItemModelPointersToCurrentItemModels)

        #How many channels we'll create
        if inputTrackCount is not None:
            num_of_input_channels = inputTrackCount
        else:
            num_of_input_channels = conf.defaultMpeChannelCount

        self._mix_with_class("MPEMasterTrackMix")

        self.item.arm = True

        if not loadingTracks:
            tempTrackIdList = []
            for x in range(1, num_of_input_channels + 1):
                tempChannel_id = self.itemId + x
                InstanceContainer.songModel.item.create_midi_track(tempChannel_id)
                tempTrackIdList.append((tempChannel_id, x))

            def set_mpeSubtrackPhase1(song, channelIdTupleList):
                for riseChannelId, mpeChannelId in channelIdTupleList:
                    trackItem = song.tracks[riseChannelId]
                    self._add_mpe_subtrack(self.parentItemModel.get_track_model_by_IMP(trackItem._live_ptr),
                                           mpeChannelId, creatingTrack=True)

                return True

            keyForCallbackPhase1 = "createMpe-Track_" + self.item.name + "_cb_for_phase1"
            InstanceContainer.add_delayed_callback(keyForCallbackPhase1, set_mpeSubtrackPhase1,
                                                 (InstanceContainer.songModel.item, tempTrackIdList), {})

        else:
            log_message("Creating mpeMastertrack-stuff, we got self.foundExternalData:", self.foundExternalData)
            for tempSubtrackModel in existingMpeTracks:
                self._add_mpe_subtrack(tempSubtrackModel)

        if conf.utilizeGhostInputTrack:
            # GhostInputTrack may be utilized to get the Arm -button to be displayed on track in Live's GUI. It is a
            # midi track with no input and no output. This way the MPE Master track records clips in sync with its input
            # tracks, and the clips can be fired in sync too. In future, the clips may be simultaneously edited as well

            # If configured to use the GhostInputTrack, if it isn't utilized already, create it if it doesn't exist, and
            # set it as input_routing_type when it's ready.
            if self.item.input_routing_type.display_name != "GhostMidiInput":
                def updateInputToGhost():
                    self.set_input_routing_type_by_types_display_name(
                        InstanceContainer.songModel._ghostMidiInputTrack.item.name)

                if InstanceContainer.songModel._ghostMidiInputTrack is None:

                    InstanceContainer.add_delayed_callback("create_GhostMidiInputTrack",
                                       InstanceContainer.songModel._create_ghostMidiInputTrack, [], {}, delayCycles=4)


                    InstanceContainer.songModel.add_ghostMidiInputTrack_listener(updateInputToGhost)

                elif not hasattr(InstanceContainer.songModel._ghostMidiInputTrack, "itemModelPointer"):
                    InstanceContainer.songModel.add_ghostMidiInputTrack_listener(updateInputToGhost)
                else:
                    updateInputToGhost()


        else:
            self.set_input_routing_type_by_types_display_name(self._mpeControllerInputTypeName)
            self.item.current_monitoring_state = 2

class GroupMasterTrackModel(TrackModel):
    """ GroupMasterTrackModel contains the functionality for group tracks. Utilized only to detect and operate MPE-group
      tracks, which simply listen and copy the color and name of their MPE Master track.
    """
    def __init__(self, *a, **kw):
        super(GroupMasterTrackModel, self).__init__(*a, **kw)
        self.itemType = "Track.GroupMasterTrack"

        #
        InstanceContainer.add_delayed_callback("checkIfIsMpeGroupingTrack-" + self.itemModelPointer,
                                             self._check_if_is_mpe_grouping_track, [], {}, delayCycles=3)

    def _check_if_is_mpe_grouping_track(self):
        self.mpeGroupedTracksMasterTrackModel = self._check_if_is_mpe_grouping_track_iterator()
        self.isMPEGroupingTrack = self.mpeGroupedTracksMasterTrackModel is not None
        log_message("GroupMasterTrackModel created! id:",self.itemId, "is isMPEGroupingTrack:",self.isMPEGroupingTrack,
                    "thamastertrack:",self.mpeGroupedTracksMasterTrackModel)


        if self.isMPEGroupingTrack:
            def setDelayedNameChange():
                def masterTracksNameChanged():
                    self.item.name = self.mpeGroupedTracksMasterTrackModel.s_name + " MPEGroup"
                    return True

                InstanceContainer.add_delayed_callback("renameMPEGroup-"+self.itemModelPointer, masterTracksNameChanged, [], {})

            setDelayedNameChange()

            self.mpeGroupedTracksMasterTrackModel.add_s_name_listener(setDelayedNameChange)

            def setDelayedColorChange():
                def masterTracksColorChanged():
                    self.item.color = self.mpeGroupedTracksMasterTrackModel.item.color
                    return True

                InstanceContainer.add_delayed_callback("recolorMPEGroup-" + self.itemModelPointer,
                                                     masterTracksColorChanged, [], {})

            setDelayedColorChange()

            self.mpeGroupedTracksMasterTrackModel.item.add_color_listener(setDelayedColorChange)


        return True

    def _check_if_is_mpe_grouping_track_iterator(self):
        masterTrackForGroupedTracks = None
        #log_message("GroupMasterTrackModel created! id:",self.itemId)
        for tempTrackIndex in range(self.itemId+1, len(InstanceContainer.songModel.item.tracks)):
            tempTrackItem = InstanceContainer.songModel.item.tracks[tempTrackIndex]
            #log_message("Checking track with name:",tempTrackItem.name)
            if tempTrackItem.is_grouped:
                tempTrackItemModel = self.parentItemModel.get_track_model_by_IMP(tempTrackItem._live_ptr)
                if not hasattr(tempTrackItemModel, "isMPESubTrack"):
                    return None
                elif not tempTrackItemModel.isMPESubTrack:
                    return None
                else:
                    if masterTrackForGroupedTracks is None:
                        masterTrackForGroupedTracks = tempTrackItemModel._MPEMasterTrackModel
                    else:
                        if masterTrackForGroupedTracks != tempTrackItemModel._MPEMasterTrackModel:
                            return None
                #log_message("Found belonging track with id:", tempTrackIndex, "and name:", tempTrackItem.name,
                #            "Has isMPESubTrack:",)
            else:
                return masterTrackForGroupedTracks
        return masterTrackForGroupedTracks

